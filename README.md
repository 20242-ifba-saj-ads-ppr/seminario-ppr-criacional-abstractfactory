# Abstract Factory

## Inten√ß√£o
Permite a cria√ß√£o de fam√≠lias de objetos relacionados ou dependentes sem especificar suas classes concretas.

## Tamb√©m conhecido como
- Kit
- F√°brica de f√°bricas

## Motiva√ß√£o
O c√≥digo a seguir representa um problema cl√°ssico de alto acoplamento e dificuldade de manuten√ß√£o. 

@import "devicesExample/badCode/src/service/DeviceFactory.ts"

O uso de estruturas como if ou switch para determinar o tipo de dispositivo e suas variantes gera as seguintes limita√ß√µes:
1. **Complexidade do Cliente**: A l√≥gica para determinar o dispositivo e seu tipo est√£o embutidas na classe DeviceFactory, tornando-a mais dif√≠cil de manter a longo prazo e testar.
2. **Dificuldade para Adicionar Novos Produtos**: Sempre que um novo tipo de dispositivo (ou variante) √© introduzido, √© necess√°rio modificar o m√©todo createDevice, violando o princ√≠pio aberto/fechado (Open/Closed Principle).

   
`üí° Um design mais modular e flex√≠vel pode ser alcan√ßado encapsulando a cria√ß√£o dos dispositivos em f√°bricas espec√≠ficas e criando assim um n√≠vel de abstra√ß√£o, eliminando a necessidade de l√≥gica condicional dentro do cliente.`


## Aplicabilidade
Use o padr√£o Abstract Factory quando:
- Um sistema precisa ser independente, gerando uma solu√ß√£o desacoplada para criar produtos relacionados.
- Um sistema precisa ser configurado com uma dentre v√°rias fam√≠lias de produtos.
- Desejar garantir que objetos de uma mesma fam√≠lia sejam usados em conjunto.
- Desejar fornecer uma biblioteca de classes de produtos sem alterar o c√≥digo do cliente e sem expor suas interfaces e implementa√ß√£o.


## Estrutura

```plantuml

    class WidgetFactory {
        +CreateScrollBar()
        +CreateWindow()
    }
    class MotifWidgetFactory extends WidgetFactory  {
        +CreateScrollBar()
        +CreateWindow()
    }
    class PMWidgetFactory  extends WidgetFactory{
        +CreateScrollBar()
        +CreateWindow()
    }
    class Client {
        +operation()
    }
    class ScrollBar
    class MotifScrollBar extends ScrollBar
    class PMScrollBar extends ScrollBar
    class Window
    class MotifWindow extends Window
    class PMWindow  extends Window

    Client --> Window
    Client --> ScrollBar
    MotifWidgetFactory --> MotifScrollBar
    MotifWidgetFactory --> MotifWindow
    PMWidgetFactory --> PMScrollBar
    PMWidgetFactory --> PMWindow
```

## Participantes

### WidgetFactory (F√°brica Abstrata)
- Define uma interface para criar fam√≠lias de objetos relacionados, como `CreateScrollBar()` e `CreateWindow()`.

### MotifWidgetFactory e PMWidgetFactory (F√°bricas Concretas)
- Implementam a interface `WidgetFactory` para criar produtos espec√≠ficos.
  - **MotifWidgetFactory**: Cria inst√¢ncias de `MotifScrollBar` e `MotifWindow`.
  - **PMWidgetFactory**: Cria inst√¢ncias de `PMScrollBar` e `PMWindow`.

### ScrollBar e Window (Produtos Abstratos)
- Representam interfaces ou classes abstratas para os tipos de produtos que ser√£o criados.
  - **ScrollBar**: Interface para barras de rolagem.
  - **Window**: Interface para janelas.

### MotifScrollBar, PMScrollBar, MotifWindow e PMWindow (Produtos Concretos)
- Implementam os produtos abstratos definidos por `ScrollBar` e `Window`.
  - **MotifScrollBar** e **PMScrollBar**: Implementa√ß√µes concretas do produto `ScrollBar`.
  - **MotifWindow** e **PMWindow**: Implementa√ß√µes concretas do produto `Window`.

### Client
- Utiliza apenas as interfaces fornecidas por `WidgetFactory`, `ScrollBar` e `Window` para criar e usar os objetos. 


## Outro exemplo

```plantuml

title F√°brica de Marcas

class Actor

interface IDeviceFactory {
    +createPhones()
    +createWatch()
}

class AndroidFactory {
    +createPhones(): AndroidPhone
    +createWatch(): AndroidWatch
}

class AppleFactory {
    +createPhones(): IPhone
    +createWatch(): IWatch
}

class Phone {
    +getDetails(): string
}

class Watch {
    +getDetails(): string
}

class AndroidPhone {
    +getDetails(): string
}

class IPhone {
    +getDetails(): string
}

class AndroidWatch {
    +getDetails(): string
}

class IWatch {
    +getDetails(): string
}

Actor --> IDeviceFactory

IDeviceFactory <|-- AndroidFactory
IDeviceFactory <|-- AppleFactory

AndroidFactory --> AndroidPhone
AndroidFactory --> AndroidWatch

AppleFactory --> IPhone
AppleFactory --> IWatch

AndroidPhone --|> Phone
IPhone --|> Phone

AndroidWatch --|> Watch
IWatch --|> Watch
```

## Participantes

### IDeviceFactory (F√°brica Abstrata)
- Define a interface para a cria√ß√£o de fam√≠lias de produtos relacionados, como `createPhones()` e `createWatch()`.

### AndroidFactory e AppleFactory (F√°bricas Concretas)
- Implementam a interface `IDeviceFactory` para criar produtos espec√≠ficos.
  - **AndroidFactory**: Cria inst√¢ncias de `AndroidPhone` e `AndroidWatch`.
  - **AppleFactory**: Cria inst√¢ncias de `IPhone` e `IWatch`.

### Phone e Watch (Produtos Abstratos)
- S√£o classes ou interfaces que definem os tipos de produtos criados pelas f√°bricas.
  - **IPhone**: Interface base para os diferentes tipos de telefones.
  - **IWatch**: Interface base para os diferentes tipos de rel√≥gios.

### AndroidPhone, IPhone, AndroidWatch e IWatch (Produtos Concretos)
- Implementam as interfaces ou classes abstratas definidas por `Phone` e `Watch`.
  - **AndroidPhone**: Implementa√ß√£o concreta do produto `Phone` para dispositivos Android.
  - **ApplePhone**: Implementa√ß√£o concreta do produto `Phone` para dispositivos Apple.
  - **AndroidWatch**: Implementa√ß√£o concreta do produto `Watch` para dispositivos Android.
  - **AppleWatch**: Implementa√ß√£o concreta do produto `Watch` para dispositivos Apple.


## Colabora√ß√µes

- **Cliente e F√°brica Abstrata**: O cliente interage com a interface da F√°brica Abstrata (`AbstractFactory`) para criar fam√≠lias de produtos relacionados, sem conhecer as classes concretas.
- **F√°brica Concreta e Produtos Concretos**: Cada F√°brica Concreta (`ConcreteFactory`) cria uma fam√≠lia espec√≠fica de produtos concretos.
- **Produtos Abstratos e Produtos Concretos**: Os produtos concretos implementam interfaces ou classes abstratas, garantindo que as f√°bricas concretas possam ser substitu√≠das sem impacto no cliente.

O cliente utiliza a F√°brica Abstrata para criar os objetos, e as F√°bricas Concretas instanciam os produtos concretos necess√°rios.


## Consequ√™ncias

### Benef√≠cios

1. **Consist√™ncia entre produtos**: Garante que os produtos criados por uma f√°brica pertencem √† mesma fam√≠lia e funcionam bem juntos.
    > Exemplo: Um sistema gr√°fico com bot√µes e barras de rolagem consistentes em estilo.
2. **Isolamento da implementa√ß√£o**: O cliente interage apenas com interfaces ou classes abstratas, deixando o c√≥digo mais flex√≠vel e desacoplado.

3. **Facilidade para introduzir novas fam√≠lias de produtos**: Adicionar uma nova fam√≠lia requer apenas criar uma nova F√°brica Concreta e seus produtos concretos.

4. **Organiza√ß√£o por fam√≠lias**: Estrutura sistemas que precisam criar objetos agrupados logicamente.


### Desvantagens

1. **Aumento da complexidade**: Implementar uma F√°brica Abstrata pode gerar muitas classes (F√°bricas Concretas e Produtos Concretos).

2. **Dificuldade em adicionar novos produtos**: Alterar a F√°brica Abstrata para incluir um novo produto afeta todas as F√°bricas Concretas existentes.


## Implementa√ß√£o

1. **Definir a F√°brica Abstrata**: Declare m√©todos para criar cada tipo de produto relacionado.

@import "devicesExample/goodCode/src/services/contracts/IDeviceFactory.ts"

2. **Implementar as F√°bricas Concretas**: Implemente a interface da F√°brica Abstrata, criando objetos espec√≠ficos de uma fam√≠lia.

@import "devicesExample/goodCode/src/services/factorys/AndroidFactory.ts"

@import "devicesExample/goodCode/src/services/factorys/AppleFactory.ts"

3. **Definir os Produtos Abstratos**: Crie interfaces ou classes abstratas para os produtos.

@import "devicesExample/goodCode/src/core/contracts/IPhone.ts"

@import "devicesExample/goodCode/src/core/contracts/IWatch.ts"

4. **Implementar os Produtos Concretos**: Implemente os produtos abstratos.

@import "devicesExample/goodCode/src/core/models/android/AndroidPhone.ts"

@import "devicesExample/goodCode/src/core/models/android/AndroidWatch.ts"

@import "devicesExample/goodCode/src/core/models/ios/ApplePhone.ts"

@import "devicesExample/goodCode/src/core/models/ios/AppleWatch.ts"

5. **Usar o Padr√£o**: O cliente cria a f√°brica concreta desejada e utiliza para criar os produtos.

@import "devicesExample/goodCode/src/main.ts"

## Usos Conhecidos

- O InterViews utiliza o padr√£o Abstract Factory para a gera√ß√£o de componentes de interface gr√°fica. Suas abstra√ß√µes-chave s√£o WidgetKit e DialogKit, que criam objetos espec√≠ficos para intera√ß√£o, e LayoutKit, que comp√µe objetos de acordo com o layout desejado. O ET++ [WGM88] tamb√©m emprega Abstract Factory para garantir portabilidade entre sistemas de janelas. Sua classe base WindowSystem define uma interface para cria√ß√£o de recursos gr√°ficos, como janelas e fontes, enquanto subclasses concretas implementam essas opera√ß√µes para diferentes sistemas. Em tempo de execu√ß√£o, uma inst√¢ncia de WindowSystem √© criada dinamicamente para fornecer os objetos apropriados.

- O padr√£o Abstract Factory da Oracle gerencia o acesso a dados em aplica√ß√µes J2EE, garantindo flexibilidade e portabilidade entre diferentes fontes de armazenamento. Suas abstra√ß√µes-chave s√£o DAOFactory e DataAccessObject. Diferentes fontes de dados s√£o implementadas como subclasses de DAOFactory, permitindo que a aplica√ß√£o selecione dinamicamente a implementa√ß√£o adequada, como OracleDAOFactory ou CloudscapeDAOFactory. O DataAccessObject abstrai o acesso ao banco de dados e delega opera√ß√µes a objetos espec√≠ficos, como CustomerDAO e AccountDAO. Essa abordagem desacopla a camada de neg√≥cios da persist√™ncia, facilitando a migra√ß√£o entre bancos de dados e promovendo reutiliza√ß√£o e manuten√ß√£o eficiente.
[Oracle: Padr√µes principais do J2EE - Objeto de acesso a dados](https://www.oracle.com/java/technologies/dataaccessobject.html)

## Padr√£o relacionados
**Factory Method**: O padr√£o AbstractFactory √© implementado com frequ√™ncia com o factory method

**Prototype**: O padr√£o AbstractFactory tamb√©m pode ser implementado utilizando prototype

**Singleton**: Uma f√°brica concreta √© freq√ºentemente um singleton

## Conclus√£o
O padr√£o **Abstract Factory** √© uma solu√ß√£o poderosa para criar fam√≠lias de objetos relacionados, mantendo a consist√™ncia e a flexibilidade do c√≥digo. Ele √© ideal para sistemas que precisam suportar m√∫ltiplas varia√ß√µes de produtos, desde que a complexidade adicional seja gerenci√°vel.

## Refer√™ncias

- GAMMA, Erich et al. Padr√µes de projeto [recurso eletr√¥nico]: solu√ß√µes reutiliz√°veis de software orientado a objetos. Tradu√ß√£o de Luiz A. Meirelles Salgado. Porto Alegre: Bookman, 2007.
- SHVETS, Alexander. Mergulho no agulho nos padr√µes de projeto. v.2021-1.16. 2021.
- ORACLE. Data Access Object (DAO). Dispon√≠vel em: https://www.oracle.com/java/technologies/dataaccessobject.html. Acesso em: 5 fev. 2025.